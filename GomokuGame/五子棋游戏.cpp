/***********************************************************************************************************************/
/*头文件*/
/***********************************************************************************************************************/
#include<stdio.h>
#include<graphics.h>
#include<conio.h>
/***********************************************************************************************************************/
/*函数声明*/
/***********************************************************************************************************************/
int first();/*游戏开场画面*/
void white(int a,int b);/*白棋*/
void black(int a,int b);/*黑棋*/
void cover(int a,int b);/*覆盖棋*/
void board();/*棋盘*/
void menu();/*菜单*/
void extend();/*伸展开始*/
void times(int s);/*步数*/
void coverword();/*覆盖步数*/
void winword(int w);/*胜方字样*/
void box(int z);/*结束对话框*/
void win(int i,int j,int su);/*判断胜负*/
/************************************************************************************************************************/
/*主函数*/
/************************************************************************************************************************/
int a[20][20];/*定义全局棋盘数组*/
void main()
{
	initgraph(640,480);
	if(first())/*如果玩家按了任意键则开始游戏*/
	{
		cleardevice();/*清屏*/
		board();/*画棋盘*/
		menu();/*画菜单*/
		MOUSEMSG m; /*定义鼠标变量*/
		while(true)/*"一重永真循环"用以捕获对"菜单栏"的鼠标信息*/
		{     
			m=GetMouseMsg();/*获取鼠标信息*/
			if(m.uMsg==WM_LBUTTONDOWN)/*按下左键*/
			{
				if((m.x>20&&m.x<100)&&(m.y>50&&m.y<100))/*识别玩家"最先"点击"开始"信息*/
					extend();
				else if((m.x>20&&m.x<100)&&(m.y>250&&m.y<300))/*识别玩家"最先"是否点击"退出"信息*/
					{closegraph();exit(0);}
			}
		}
	}
}
/************************************************************************************************************************/
/*函数定义*/
/************************************************************************************************************************/
int first()/*游戏开场画面*/
{
	setcolor(BROWN);/*"五子棋游戏"封面*/
	setfillstyle(BROWN,24);
	fillcircle(240,200,20);
	fillcircle(280,200,20);
	fillcircle(320,200,20);
	fillcircle(360,200,20);
	fillcircle(400,200,20);
	setcolor(WHITE);
	setbkmode(TRANSPARENT);/*字样背景色设置为透明*/
	outtextxy(233,193,"五");
	outtextxy(273,193,"子");
	outtextxy(313,193,"棋");
	outtextxy(353,193,"游");
	outtextxy(393,193,"戏");
	outtextxy(283,235,"By Chicken");
	setbkmode(OPAQUE);/*字样背景色还原*/

	IMAGE tmp;/*存储图像对象*/
	getimage(&tmp,0,0,textwidth("按任意键进入"),textheight("按任意键进入"));/*保存当前图像*/
	while(1)/*如果不按开始就一直移动*/
	{
		for(int i=0;i<510;i++)/*字样在横坐标0-510范围移动*/
		{
			outtextxy(i,450,"按任意键进入");
			Sleep(20);/*延时*/
			putimage(i,450,&tmp);/*打印被保存图像*/
			if(kbhit())/*按键信息*/
				return 1;

		}
		for(;i>0;i--)/*循环移动*/
		{
			outtextxy(i,450,"按任意键进入");
			Sleep(20); 
			putimage(i,450,&tmp);
			if(kbhit())
				return 1;
		}
	}
}
/************************************************************************************************************************/
void white(int a,int b)/*白棋*/
{
	setcolor(WHITE);
	setfillstyle(WHITE);
	fillcircle((a-120)/20*20+130,(b-50)/20*20+60,9);/*棋子居中*/
}
/************************************************************************************************************************/
void black(int a,int b)/*黑棋*/
{
	setcolor(BLACK);
	setfillstyle(BLACK);
	fillcircle((a-120)/20*20+130,(b-50)/20*20+60,9);/*棋子居中*/
}
/************************************************************************************************************************/
void cover(int a,int b)/*覆盖棋*/
{	
	setcolor(WHITE);
	setfillstyle(BROWN,24);
	fillrectangle((a-120)/20*20+120,(b-50)/20*20+50,(a-120)/20*20+140,(b-50)/20*20+70);	
}
/************************************************************************************************************************/
void board()/*棋盘*/
{
	int k;
	setcolor(WHITE);/*声明现在的边框颜色*/
	setfillstyle(BROWN,24);/*声明现在的填充颜色*/
	bar(120,50,520,450);/*填充矩形范围*/
	for(k=0;k<21;k++)/*画20x20的格子线*/
	{
		 line(120+20*k,50,120+20*k,450);
		 line(120,50+20*k,520,50+20*k);
	}
}
/************************************************************************************************************************/
void menu()/*菜单*/
{
	setcolor(WHITE);
	setfillstyle(BROWN,24);
	setbkmode(BROWN);
	bar(20,50,100,100);/*开始框*/
	rectangle(20,50,100,100);/*加边框*/
	bar(20,150,100,200);/*重来框*/
	rectangle(20,150,100,200);
	bar(20,250,100,300);/*退出框*/
	rectangle(20,250,100,300);
	bar(20,350,100,450);/*状态框*/
	rectangle(20,350,100,450);
	outtextxy(45,68,"开始");
	outtextxy(45,168,"重来");
	outtextxy(45,268,"退出");
	outtextxy(22,354,"棋方:");
	outtextxy(22,391,"步数:");
	outtextxy(22,430,"胜方:");
}
/************************************************************************************************************************/
void extend()/*伸展开始*/
{
	int i,j,k/*循环变量*/,sum/*总步数记录*/;
	int lastx=300,lasty=300;/*记录当前鼠标前一时刻所在的横纵坐标*/
	for(i=0;i<20;i++)/*将棋盘上的每一格用0记为空棋位*/
		for(j=0;j<20;j++)
			a[i][j]=0;
	sum=0;coverword();/*重来时将上次残留的步数数字覆盖*/times(sum);/*初始步数是0步*/
	for(k=0;k<200;k++)/*黑白棋总共最多各下200颗*/
	{
/******************************************************黑棋操作**********************************************************/
		MOUSEMSG m; /*定义鼠标变量*/
		while(true)/*"二重永真循环"用以捕获对"棋盘"的鼠标信息*/
		{	
			black(55,365);/*画出当前棋方图样*/
			m=GetMouseMsg();
			if(a[(lasty-50)/20][(lastx-120)/20]==0)/*第一次是充数,之后每一次都要检验上一时刻鼠标所在位置有无棋子*/
				cover(lastx,lasty);/*空棋位:第一次是充数,之后每一次都要把上一时刻遗留下来的棋子光标覆盖还原成棋盘颜色*/
			if((m.x>120&&m.x<520)&&(m.y>50&&m.y<450))/*识别玩家"游戏中"点击"棋盘"信息*/
			{		
				if(a[(m.y-50)/20][(m.x-120)/20]==0)/*鼠标所在位置是空棋位*/
				{	
					black(m.x,m.y);/*在鼠标位置打印黑棋子*/
					lastx=m.x;lasty=m.y;/*存储当前时刻鼠标坐标,以备下一次覆盖使用*/
				}			
				if(m.uMsg==WM_LBUTTONDOWN)
				{
					i=(m.y-50)/20;j=(m.x-120)/20;/*将坐标转化为数组下标*/							
					if(a[i][j]==0)/*检查是否为空棋位*/
					{	
						a[i][j]=1;/*1代表黑棋标记*/
						sum++;coverword();times(sum);/*记录并显示步数*/
						black(m.x,m.y);/*画黑棋*/
						win(i,j,sum);/*判定胜负*/
						break;
					}
				}
			}
			else if(m.uMsg==WM_LBUTTONDOWN&&(m.x>20&&m.x<100)&&(m.y>150&&m.y<200))/*识别玩家"游戏中"点击"重来"信息*/
					{board();extend();}/*刷新棋盘并回归到"二重永真循环"对"棋盘"的鼠标信息*/
			else if(m.uMsg==WM_LBUTTONDOWN&&(m.x>20&&m.x<100)&&(m.y>250&&m.y<300))/*识别玩家"游戏中"点击"退出"信息*/
					{closegraph();exit(0);}/*关闭窗口并退出操作系统*/
		}

/******************************************************白棋操作**********************************************************/
		while(true)
		{
			white(55,365);
			m=GetMouseMsg();
			if(a[(lasty-50)/20][(lastx-120)/20]==0)
				cover(lastx,lasty);
			if((m.x>120&&m.x<520)&&(m.y>50&&m.y<450))
			{
				if(a[(m.y-50)/20][(m.x-120)/20]==0)
				{
					white(m.x,m.y);/*在鼠标位置打印白棋子*/
					lastx=m.x;lasty=m.y;	
				}
				if(m.uMsg==WM_LBUTTONDOWN)
				{
					i=(m.y-50)/20;j=(m.x-120)/20;
					if(a[i][j]==0)
					{   
						a[i][j]=2;/*2代表白棋标记*/
						sum++;coverword();times(sum);
						white(m.x,m.y);
						win(i,j,sum);
						break;
					}
				}
			}
			else if(m.uMsg==WM_LBUTTONDOWN&&(m.x>20&&m.x<100)&&(m.y>150&&m.y<200))/*识别玩家"游戏中"点击"重来"信息*/
					{board();extend();}
			else if(m.uMsg==WM_LBUTTONDOWN&&(m.x>20&&m.x<100)&&(m.y>250&&m.y<300))/*识别玩家"游戏中"点击"退出"信息*/
					{closegraph();exit(0);}
		}
	}
}
/************************************************************************************************************************/
void times(int s)/*步数*/
{
	char s1[5];
	setcolor(WHITE);/*声明当前字体颜色*/
	sprintf(s1,"%d",s);/*整型转换成字符型*/
	outtextxy(62,391,s1);
}
/************************************************************************************************************************/
void coverword()/*覆盖步数*/
{	
	setfillstyle(BROWN,24);
	bar(60,393,90,410);
}
/************************************************************************************************************************/
void winword(int w)/*胜方字样*/
{
	char str7[10]="黑方",str8[10]="白方";
	setcolor(WHITE);
	if(w==1)/*1表示黑棋*/
		outtextxy(60,430,str7);
	else
		outtextxy(60,430,str8);
}
/************************************************************************************************************************/
void box(int z)/*结束对话框*/
{
	switch(z)/*唯一不确定的是num到底是黑还是白棋*/
	{
	case 1:winword(1);/*是黑棋,打印"黑方"字样*/
		{
			HWND wnd=GetHWnd();/*获取一个对话框*/
			if (MessageBox(wnd,"黑方胜利!\n是否重来?","询问",MB_YESNO|MB_ICONQUESTION)==IDYES)/*对话框*/  /*对话框内容*/  /*对话框名称*/  /*按钮提示*/
				{board();extend();}/*返回主函数顶端重新开始*/
			else {closegraph();exit(0);}
		}
	case 2:winword(2);/*是白棋,打印"白方"字样*/
		{
			HWND wnd=GetHWnd();
			if (MessageBox(wnd,"白方胜利!\n是否重来?","询问",MB_YESNO|MB_ICONQUESTION)==IDYES)
				{board();extend();}
			else {closegraph();exit(0);}
		}
	}
}
/************************************************************************************************************************/
void win(int i,int j,int su)/*判断胜负*/
{	
	int m,n,r,s,num=a[i][j]/*用变量num接收"中心棋子"的颜色,提高程序的灵活性*/;
	int t1=0,t2=0,t3=0,t4=0;/*分别用来标记\竖行\横行\左斜\右斜\是否成"五连子"的标记变量*/
	if(su!=400)/*排除和局情况*/
	{
		/*竖行*/
		 for(m=i-4;m<=i;m++)/*对"中心棋子"的上下各4颗棋子,取"队长棋子"颜色*/
		{
			for(n=m;n<m+5;n++)/*n是用来推移棋子的变量,同时又不影响m的值*/
			{
				if(a[n][j]==num&&(n>=0&&n<=19))/*防止n越出棋盘*/
					t1=1;/*1表示符合"中心棋子"的颜色*/
				else
					{t1=0;break;}/*0表示不符合"中心棋子"的颜色,一旦不符合,则停止查找,增强程序效率*/
			}
			if(t1==1)/*表明存在满足"五连子"的情况*/
				box(num);/*弹出结束对话框*/
		}

	   /*横行*/
		for(m=j-4;m<=j;m++)
		{
			for(n=m;n<m+5;n++)
			{	
				if(a[i][n]==num&&(n>=0&&n<=19))
					t2=1;
				else
					{t2=0;break;}
			}
			if(t2==1)
				box(num);
		}
	
	   /*左斜*/
		for(m=i-4,n=j-4;m<=i;m++,n++)
		{
			for(r=m,s=n;r<m+5;r++,s++)/*r和s是用来推移棋子的变量,同时又不影响m和n的值*/
			{
				if((r>=0&&r<=19)&&(s>=0&&s<=19)&&a[r][s]==num)/*防止r\s越出棋盘*/
					t3=1;
				else
					{t3=0;break;}	
			}
			if(t3==1)
				box(num);
		}

	   /*右斜*/
		for(m=i-4,n=j+4;m<=i;m++,n--)
		{
			for(r=m,s=n;r<m+5;r++,s--)
			{
				if(a[r][s]==num&&(r>=0&&r<=19)&&(s>=0&&s<=19))
					t4=1;
				else
					{t4=0;break;}
			}
			if(t4==1)
				box(num);
		}
	}

	if(su==400)/*和局情况*/
	{
		HWND wnd=GetHWnd();
		if (MessageBox(wnd,"本次和局!\n是否重来?","询问",MB_YESNO|MB_ICONQUESTION)==IDYES)
			{board();extend();}
		else {closegraph();exit(0);}
	}
}
/************************************************************************************************************************/